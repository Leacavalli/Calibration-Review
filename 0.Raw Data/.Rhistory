mutate(Study.setting = ifelse(Study.setting %in% c("United States", "USA"), "United States of America", Study.setting))|>
mutate(Study.setting = ifelse(Study.setting %in% c("eSwatini ", "Swaziland"), "Eswatini", Study.setting))|>
mutate(Study.setting = ifelse(Study.setting %in% c("UK"), "United Kingdom", Study.setting))|>
mutate(Study.setting = ifelse(Study.setting %in% c("Russia"), "Russian Federation", Study.setting))|>
mutate(Study.setting = str_replace(Study.setting, ", and ", ", "))|>
mutate(Study.setting = str_replace(Study.setting, "and ", ", "))|>
mutate(Study.setting = gsub(";", ",", Study.setting))|>
mutate(Study.setting = gsub(" \n", ", ", Study.setting))|>
mutate(Study.setting = gsub("\n", ", ", Study.setting))|>
mutate(Study.setting = gsub(",,", ",", Study.setting))
# Explore country names
Calibration_data_V2 |>
group_by(Study.setting) |>
summarise(N=n())|>
arrange(-N)
# Explore country names not in typical categories
unique(Calibration_data_V2|>
filter(! Study.setting %in% list_countries) |>
pull(Study.setting))
Calibration_data_V3 <- Calibration_data_V2 |>
mutate(What.justification.was.provided.for.choice.of.parameters.to.calibrate. = ifelse(What.justification.was.provided.for.choice.of.parameters.to.calibrate.== "Parameters are uncertain", "Parameters are uncertain.", What.justification.was.provided.for.choice.of.parameters.to.calibrate.))|>
mutate(External.beliefs.or.evidence = ifelse(External.beliefs.or.evidence== "Other: No prior knowledge is incorporated for parameters to be calibrated.", "No prior knowledge is incorporated for parameters to be calibrated. ", External.beliefs.or.evidence))|>
mutate(How.many.calibration.targets.were.used.for.estimation. = ifelse(How.many.calibration.targets.were.used.for.estimation.== "Other: Single", "Single ", How.many.calibration.targets.were.used.for.estimation.))|>
mutate(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm = ifelse(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm== "Other: Not clear ", "Not clear", Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm))|>
mutate(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm = ifelse(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm== "Other: Other", "Other ", Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm))|>
mutate(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm = ifelse(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm== "Other: Ad-Hoc Distance", "Ad-hoc distance function (as in Approximate Bayesian Computation or least squares)", Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm))|>
mutate(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm = ifelse(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="Data likelihood", "Data likelihood " , Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm))|>
mutate(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm = ifelse(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="Other: Data likelihood", "Data likelihood " , Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm))|>
mutate(Nature.of.calibration.results = ifelse(Nature.of.calibration.results== "Other: Sample estimate", "Sample estimate (multiple parameter sets)", Nature.of.calibration.results))|>
mutate(Nature.of.calibration.results = ifelse(Nature.of.calibration.results== "Other: Point estimate", "Point estimate (single parameter / parameter set)", Nature.of.calibration.results))|>
mutate(Nature.of.calibration.results = ifelse(Nature.of.calibration.results=="Point estimate (single parameter set)", "Point estimate (single parameter / parameter set)" , Nature.of.calibration.results)) |>
mutate(Nature.of.calibration.results = ifelse(Nature.of.calibration.results=="Not reported", "Not reported " , Nature.of.calibration.results))|>
mutate(Nature.of.calibration.results = ifelse(Nature.of.calibration.results=="Other: Parameter estimate ", "Point estimate (single parameter / parameter set)" , Nature.of.calibration.results))|>
mutate(Stochasticity.in.model = ifelse(Stochasticity.in.model== "Other: Stochastic", "Stochastic model ", Stochasticity.in.model))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm== "Other: Other", "Other ", Name.of.calibration.algorithm))|>
mutate(Model.type = ifelse(Model.type== "Other: Individual-based", "Individual-based", Model.type))|>
mutate(How.many.parameters.were.calibrated. = ifelse(How.many.parameters.were.calibrated.== "Other: Single", "Single ", How.many.parameters.were.calibrated.))|>
mutate(How.many.calibration.targets.were.used.for.estimation. = ifelse(How.many.calibration.targets.were.used.for.estimation.== "Other: Multiple", "Multiple ", How.many.calibration.targets.were.used.for.estimation.))|>
mutate(Number.of.steps..single.or.sequential. = ifelse(Number.of.steps..single.or.sequential.== "Other: \nNot reported", "Not reported", Number.of.steps..single.or.sequential.))|>
mutate(Number.of.steps..single.or.sequential. = ifelse(Number.of.steps..single.or.sequential.== "Not reported ", "Not reported", Number.of.steps..single.or.sequential.))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm== "Other: Not reported ", "Not reported", Name.of.calibration.algorithm))|>
mutate(Number.of.steps..single.or.sequential. = ifelse(Number.of.steps..single.or.sequential.== "Other: Calibration was done as a single step (i.e., all parameters were calibrated at once).", "Calibration was done as a single step (i.e., all parameters were calibrated at once). ", Number.of.steps..single.or.sequential.))|>
mutate(Resolution.of.data..used.for.defining.calibration.targets = ifelse(Resolution.of.data..used.for.defining.calibration.targets== "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data)", "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) " , Resolution.of.data..used.for.defining.calibration.targets))|>
mutate(Resolution.of.data..used.for.defining.calibration.targets = ifelse(Resolution.of.data..used.for.defining.calibration.targets== "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data), Modeled estimates (e.g., WHO TB incidence estimates)", "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ; Modeled estimates  (e.g., WHO TB incidence estimates)" , Resolution.of.data..used.for.defining.calibration.targets))|>
mutate(Resolution.of.data..used.for.defining.calibration.targets = ifelse(Resolution.of.data..used.for.defining.calibration.targets== "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data), and Modeled estimates (e.g., WHO TB incidence estimates)", "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ; Modeled estimates  (e.g., WHO TB incidence estimates)" , Resolution.of.data..used.for.defining.calibration.targets))|>
mutate(Resolution.of.data..used.for.defining.calibration.targets = ifelse(Resolution.of.data..used.for.defining.calibration.targets== "Modeled estimates (e.g., WHO TB incidence estimates), Empirical data or statistical summaries of empirical data (e.g., WHO case notification data)", "Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ; Modeled estimates  (e.g., WHO TB incidence estimates)" , Resolution.of.data..used.for.defining.calibration.targets))|>
mutate(Resolution.of.data..used.for.defining.calibration.targets = ifelse(Resolution.of.data..used.for.defining.calibration.targets== "Modeled estimates (e.g., WHO TB incidence estimates)", "Modeled estimates  (e.g., WHO TB incidence estimates)" , Resolution.of.data..used.for.defining.calibration.targets))|>
mutate(How.many.calibration.targets.were.used.for.estimation. = ifelse(How.many.calibration.targets.were.used.for.estimation.== "Multiple", "Multiple " , How.many.calibration.targets.were.used.for.estimation.))|>
mutate(How.many.calibration.targets.were.used.for.estimation. = ifelse(How.many.calibration.targets.were.used.for.estimation.== "Single", "Single " , How.many.calibration.targets.were.used.for.estimation.))|>
mutate(Number.of.steps..single.or.sequential. = ifelse(Number.of.steps..single.or.sequential.== "Calibration was done as a single step (i.e., all parameters were calibrated at once).", "Calibration was done as a single step (i.e., all parameters were calibrated at once). " , Number.of.steps..single.or.sequential.))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Bayesian history matching", "Bayesian history matching" , Other_Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Bayesian history matching", "Other " , Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="acceptance-rejection method ", "acceptance-rejection method " , Other_Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="acceptance-rejection method ", "Other " , Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Incremental Mixture Importance Sampling ","Incremental Mixture Importance Sampling " , Other_Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Incremental Mixture Importance Sampling ", "Other " , Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Nelder-Mead Simplex Method","Nelder-Mead Simplex Method" , Other_Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Nelder-Mead Simplex Method", "Other " , Name.of.calibration.algorithm))|>
mutate(Is.calibration.implementation..code..available.in.an.open.access.repository. = ifelse(Is.calibration.implementation..code..available.in.an.open.access.repository.=="Not reported", "Not reported " , Is.calibration.implementation..code..available.in.an.open.access.repository.))  |>
mutate(Do.authors.list.any.programming.packages.used.for.calibration. = ifelse(Do.authors.list.any.programming.packages.used.for.calibration.=="Not reported", "No" , Do.authors.list.any.programming.packages.used.for.calibration.)) |>
mutate(Do.authors.list.any.programming.packages.used.for.calibration. = ifelse(Do.authors.list.any.programming.packages.used.for.calibration.=="No ", "No" , Do.authors.list.any.programming.packages.used.for.calibration.))  |>
mutate(How.are.calibration.results.reported. = ifelse(How.are.calibration.results.reported.=="Graphical" , "Graphical: e.g., as a plot of calibrated model trend versus calibration targets. " , How.are.calibration.results.reported.)) |>
mutate(How.are.calibration.results.reported. = ifelse(How.are.calibration.results.reported.=="Numerical: e.g. as value(s), Graphical: e.g., as a plot of calibrated model trend versus calibration targets.\n\n", "Numerical: e.g. as value(s).; Graphical: e.g., as a plot of calibrated model trend versus calibration targets. " , How.are.calibration.results.reported.)) |>
mutate(How.are.calibration.results.reported. = ifelse(How.are.calibration.results.reported.=="Numerical: e.g. as value(s)., Graphical: e.g., as a plot of calibrated model trend versus calibration targets." , "Numerical: e.g. as value(s).; Graphical: e.g., as a plot of calibrated model trend versus calibration targets. " , How.are.calibration.results.reported.)) |>
mutate(How.are.calibration.results.reported. = ifelse(How.are.calibration.results.reported.=="Not reported" , "Calibration results are not reported. " , How.are.calibration.results.reported.))|>
mutate(How.is.uncertainty.in.calibration.outputs.reported. = ifelse(How.is.uncertainty.in.calibration.outputs.reported.== "Not reported " , "Uncertainty in calibration outputs is not reported.", How.is.uncertainty.in.calibration.outputs.reported.))|>
mutate(How.is.uncertainty.in.calibration.outputs.reported. = ifelse(How.is.uncertainty.in.calibration.outputs.reported.== "Graphical" , "Graphical: As a plot; e.g., a line with shaded areas indicating uncertainty intervals ", How.is.uncertainty.in.calibration.outputs.reported.)) |>
mutate(How.is.uncertainty.in.calibration.outputs.reported. = ifelse(How.is.uncertainty.in.calibration.outputs.reported.== "Numerical: As uncertainty intervals around estimates or model outputs. e.g., 95% CI: 1.5 - 4.5., Graphical: As a plot; e.g., a line with shaded areas indicating uncertainty intervals" , "Numerical: As uncertainty intervals around estimates or model outputs. e.g., 95% CI: 1.5 - 4.5.; Graphical: As a plot; e.g., a line with shaded areas indicating uncertainty intervals ", How.is.uncertainty.in.calibration.outputs.reported.))  |>
mutate(Model.type = ifelse(Model.type== "Compartmental ", "Compartmental", Model.type))|>
mutate(Model.type = ifelse(Model.type== "Individual-based ", "Individual-based", Model.type))|>
mutate(Stochasticity.in.model = ifelse(Stochasticity.in.model== "Stochastic model ", "Stochastic model" , Stochasticity.in.model))|>
mutate(Stochasticity.in.model = ifelse(Stochasticity.in.model== "deterministic", "Deterministic model " , Stochasticity.in.model))|>
mutate(External.beliefs.or.evidence = ifelse(External.beliefs.or.evidence== "Prior knowledge is incorporated for at least one parameter to be calibrated; e.g., as a prior distribution over the parameter", "Prior knowledge is incorporated for at least one parameter to be calibrated; e.g., as a prior distribution over the parameter." , External.beliefs.or.evidence))|>
mutate(What.justification.was.provided.for.choice.of.parameters.to.calibrate. = ifelse(What.justification.was.provided.for.choice.of.parameters.to.calibrate.== "Not reported", "Not reported ", What.justification.was.provided.for.choice.of.parameters.to.calibrate.))
# 0.1 Year published
table(Calibration_data_V3$Year.published)
# 0.2 Disease type
table(Calibration_data_V3$Disease.type..choose.all.that.apply.)
# 0.3 Model type
table(Calibration_data_V3$Model.type)
# 0.4 Stochasticity in model
table(Calibration_data_V3$Stochasticity.in.model)
# A.1 Scientific problem being solved (what is the purpose of calibration?)
table(Calibration_data_V3$Scientific.problem.being.solved)
# B.1.1. Beliefs or evidence
table(Calibration_data_V3$External.beliefs.or.evidence)
# B.1.2. Choice of parameters to calibrate
table(Calibration_data_V3$Choice.of.parameters.to.calibrate)
# B.1.3. What justification was provided for choice of parameters to calibrate? Only for studies which calibrated a subset of parameters.
table(Calibration_data_V3$What.justification.was.provided.for.choice.of.parameters.to.calibrate.)
# B.1.4. How many parameters were calibrated?
table(Calibration_data_V3$How.many.parameters.were.calibrated.)
# B.2.2. Resolution of data used for defining calibration targets
table(Calibration_data_V3$Resolution.of.data..used.for.defining.calibration.targets)
#  B.2.3.  How many calibration targets were used for estimation?
table(Calibration_data_V3$How.many.calibration.targets.were.used.for.estimation.)
# C.1. Number of steps
table(Calibration_data_V3$Number.of.steps..single.or.sequential.)
# C.2. Name of calibration algorithm
table(Calibration_data_V3$Name.of.calibration.algorithm)
# C.3. Is calibration implementation (code) available in an open-access repository?
table(Calibration_data_V3$Is.calibration.implementation..code..available.in.an.open.access.repository.)
# C.4. Goodness-of-fit (GOF) measure employed within calibration algorithm
table(Calibration_data_V3$Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm)
# C.5. What programming language was used for calibration?
table(Calibration_data_V3$What.programming.language.was.used.for.calibration.)
# C.6. Do authors list any programming packages used for calibration?
table(Calibration_data_V3$Do.authors.list.any.programming.packages.used.for.calibration.)
# D.1. Nature of calibration results
table(Calibration_data_V3$Nature.of.calibration.results)
# D.2. How are calibration results reported?
table(Calibration_data_V3$How.are.calibration.results.reported.)
# D.3. How is uncertainty in calibration outputs reported?
table(Calibration_data_V3$How.is.uncertainty.in.calibration.outputs.reported.)
# D.4. What is the size of the calibration output?
table(Calibration_data_V3  |>
mutate(size.of.the.calibration.output.reported = ifelse(What.is.the.size.of.the.calibration.output. == "Not reported", "Not reported", "[Number provided]"))|>
pull(size.of.the.calibration.output.reported))
# If number provided, what is the range of the reported size?
Calibration_data_V3  |>
mutate(size.of.the.calibration.output.reported = ifelse(What.is.the.size.of.the.calibration.output. == "Not reported", "Not reported", "[Number provided]"))|>
filter(size.of.the.calibration.output.reported != "Not reported")|>
pull(What.is.the.size.of.the.calibration.output.)
clean_data <- Calibration_data_V3
# 1. Model.type
# Check inconsistencies
clean_data |> group_by(Model.type) |> summarise(N=n())
clean_data |> filter(Model.type=="Other") |> select(Model.type, Other_Model.type)
clean_data |> filter(Other_Model.type != "", Model.type!="Other") |>select(Model.type, Other_Model.type)
# Clean inconsistencies
clean_data_V1 <- clean_data |> mutate(Other_Model.type = ifelse(Other_Model.type == "105 LMICs (Country names not reported)", "", Other_Model.type))
# 2. What.justification.was.provided.for.choice.of.parameters.to.calibrate
# Check inconsistencies
clean_data |> group_by(What.justification.was.provided.for.choice.of.parameters.to.calibrate.) |> summarise(N=n())
clean_data |>
filter(What.justification.was.provided.for.choice.of.parameters.to.calibrate.=="Other") |>
select(What.justification.was.provided.for.choice.of.parameters.to.calibrate., Other_What.justification.was.provided.for.choice.of.parameters.to.calibrate.)
clean_data |>
filter(Other_What.justification.was.provided.for.choice.of.parameters.to.calibrate. != "",
What.justification.was.provided.for.choice.of.parameters.to.calibrate.!="Other") |>
select(What.justification.was.provided.for.choice.of.parameters.to.calibrate., Other_What.justification.was.provided.for.choice.of.parameters.to.calibrate.)
# no inconsistencies
# 3. Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.
# Check inconsistencies
clean_data |> group_by(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.) |> summarise(N=n())
clean_data |>
filter(grepl("Other",Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.),
Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. == "")|>
select(Covidence.ID)
clean_data |>
filter(Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. != "",
! grepl("Other",Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)) |>
select(Covidence.ID)
# no inconsistencies
# 4. Name.of.calibration.algorithm
# Check inconsistencies
clean_data |>
filter(Name.of.calibration.algorithm=="Other ") |>
filter(Other_Name.of.calibration.algorithm=="") |>
pull(Covidence.ID)
clean_data |>
filter(Other_Name.of.calibration.algorithm != "",
Name.of.calibration.algorithm !="Other ") |>
select(Name.of.calibration.algorithm, Other_Name.of.calibration.algorithm)
# Clean inconsistencies
clean_data_V2 <- clean_data_V1 |>
mutate(Other_Name.of.calibration.algorithm = ifelse(Other_Name.of.calibration.algorithm == "A Bayesian framework", "", Other_Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Other_Name.of.calibration.algorithm == " ", "", Other_Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm = ifelse(Other_Name.of.calibration.algorithm == "Not reported", "", Other_Name.of.calibration.algorithm))
# 5. Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm
# Check inconsistencies
clean_data |>
filter(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="Other ") |>
filter(Other_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="") |>
select(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm, Other_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm, Not_Clear_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm)
clean_data |>
filter(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="Not clear") |>
filter(Not_Clear_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm=="") |>
select(Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm, Other_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm, Not_Clear_Goodness.of.fit..GOF..measure.employed.within.calibration.algorithm)
# no inconsistencies
# 6. Nature.of.calibration.results
# Check inconsistencies
clean_data |>
filter(Nature.of.calibration.results=="Other ") |>
select(Nature.of.calibration.results, Other_Nature.of.calibration.results)
clean_data |>
filter(Other_Nature.of.calibration.results != "",
Nature.of.calibration.results != "Other ") |>
select(Nature.of.calibration.results, Other_Nature.of.calibration.results)
# no inconsistencies
# 7. How.are.calibration.results.reported.
# Check inconsistencies
clean_data |> group_by(How.are.calibration.results.reported.) |> summarise(N=n())
clean_data |> filter(Other_How.are.calibration.results.reported. != "")
# no inconsistencies
# 8. How.is.uncertainty.in.calibration.outputs.reported.
# Check inconsistencies
clean_data |> group_by(How.is.uncertainty.in.calibration.outputs.reported.) |> summarise(N=n())
clean_data |> filter(Other_How.is.uncertainty.in.calibration.outputs.reported. != "")
# no inconsistencies
# Final formating
clean_data_V3 <- clean_data_V2  |>
mutate(across(contains("Other_"), ~ ifelse(. == "", NA, .)))|>
mutate(across(contains("Not_Clear_"), ~ ifelse(. == "", NA, .)))
# Format correctly the "Type of data" column
clean_data_V4 <- clean_data_V3|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., ", ", "; "))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "e.g.;", "e.g.,"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "mortality;", "mortality,"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "size;", "size,"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "partners;", "partners,"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., " temperature; humidity;", " temperature, humidity,"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace_all(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., " ; ", "; "))
# Upload data for recoding the "Other type of data" column
setwd("~/GitHub/Calibration-Review/0.Raw Data")
Other_Type.of.data <- read.xlsx("Other_Type.of.data.used.for.defining.calibration.targets.xlsx", sheetName = "Sheet1")
# Make one row per study (i.e. merge the several types of data)
Other_Type.of.data_V2 <- Other_Type.of.data |>
filter(Category.1 == "Other ")%>%
group_by(Covidence.ID) %>%
summarize(Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. = paste(Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., collapse = ", "))
# Subset the studies that do have "Other' type of data
Other_Type.of.data_V3 <- Other_Type.of.data %>%
group_by(Covidence.ID) %>%
summarize(Type = paste(Category.1, collapse = "; "))
# Join
Other_Type.of.data_V4 <- left_join(Other_Type.of.data_V3, Other_Type.of.data_V2) |>
mutate(Covidence.ID= as.character(Covidence.ID))|>
mutate(Type= str_replace_all(Type, " ; ", "; "))
# Subset the studies that have "Other" type of data
clean_data_sub_Other <- clean_data_V4 %>%
filter(grepl("Other", Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))%>%
select(Covidence.ID, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)%>%
unique()
# Recode the type of data and "Other' for these studies
## Recode function to remove duplicate types of data and list "Other' last
recode_categories <- function(x) {
# Split the string by ";"
elements <- unlist(strsplit(x, "; "))
# Remove duplicates
unique_elements <- unique(elements)
# Separate "Other" if it exists
if ("Other" %in% unique_elements) {
unique_elements <- unique_elements[unique_elements != "Other"]
unique_elements <- c(unique_elements, "Other")
}
# Combine elements back into a string
return(paste(unique_elements, collapse = "; "))
}
## Recode
clean_data_sub_Other_recode <- left_join(clean_data_sub_Other, Other_Type.of.data_V4) |>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_remove(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "; Other "))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_remove(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "; Other"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_remove(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., "Other"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.=ifelse(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.==" ", Type, paste(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., Type, sep= "; ")))|>
select(Covidence.ID, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.= str_replace(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., " ; ", "; "))%>%
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. = sapply(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., recode_categories))
# Merge the studies that did and did not have "Other" types of data
## Subset the studies that do not have "Other" type of data
clean_data_sub_no_Other <- clean_data_V4 %>%
filter(! grepl("Other", Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)) %>%
select(Covidence.ID, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.,
Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)
## Merge
clean_data_Type_recode <- rbind(clean_data_sub_no_Other, clean_data_sub_Other_recode)
# Join the recoded column to the original data
clean_data_V5 <- left_join((clean_data_V4 %>%
select(-Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., - Other_Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)),
clean_data_Type_recode) |>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. = str_replace(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.,"Incidence ", "Incidence"))|>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. = str_replace(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.,"Time to event ", "Time to event")) |>
mutate(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply. = str_replace(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.,"Other ", "Other"))
# Clean "Bayesian Melding" studies
clean_data_V6 <- clean_data_V5 |>
mutate(Name.of.calibration.algorithm = ifelse(Name.of.calibration.algorithm=="Approximate Bayesian Computation", "Approximate Bayesian Computation (ABC)", Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm= ifelse(Covidence.ID == 1393, "Markov Chain Monte Carlo", Name.of.calibration.algorithm))|>
mutate(Name.of.calibration.algorithm= ifelse(Covidence.ID == 1847, "Other ", Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm= ifelse(Covidence.ID == 1393, NA, Other_Name.of.calibration.algorithm))|>
mutate(Other_Name.of.calibration.algorithm= ifelse(Covidence.ID == 1847, "Sampling importance resampling (SIR)", Other_Name.of.calibration.algorithm))
# Make vectors containing all versions of each algorithm's name
ABC_SMC_names <- c("Approximate Bayesian Computation Sequential Monte Carlo scheme",
"Approximate Bayesian computation with sequential Monte Carlo sampling",
"Approximate Bayesian Computation with Sequential Monte Carlo Sampling",
"Aproximate Bayesian Computation Sequential Monte Carlo (ABC-SMC) algorithm ",
"Approximate Bayesian Computation Sequential Monte Carlo (ABC SMC) method",
"Approximate Bayesian Computation with Sequential Monte Carlo sampling (ABC-SMC) method")
HME_names <- c("History matching with emulation",
"history matching with model emulation",
"history matching with emulation",
" history matching with emulation")
IMIS_names <- c("incremental mixture importance sampling",
"Incremental mixture importance sampling",
"Incremental Mixture Importance Sampling",
" Incremental Mixture Importance Sampling",
"incremental mixture importance sampling (IMIS)",
"Incremental Mixture Importance Sampling (IMIS) ",
"a Bayesian framework with incremental mixture importance sampling",
"Incremental Mixture Importance Sampling", "Incremental Mixture Importance Sampling ")
MCF_names <- c("Monte-Carlo filtering",
"Monte-Carlo filtering ",
"Monte Carlo filtering")
BM_names <- c("Bayesian melding",
" Bayesian melding")
NM_names <- c("Iterative, directed-search Nelder-Mead (NM) method",
"Nelder-Mead algorithm ","Nelder-Mead Simplex Method" ,
"Nelder-Mead")
SIR_names <- c("sample-importance-resampling ",
"Sampling importance resampling ",
"Sampling Importance Resampling",
"Sampling importance resampling",
"Semi-Bayesian Sampling/Importance-Resampling algorithm",
"Sampling-importance-resampling (SIR) approach")
SMC_PF_names <- c("sequential Monte Carlo method based on particle filtering",
"sequential Monte Carlo method based on particle filtering",
"particle Markov\nchain Monte Carlo (PMCMC",
"Sequential Monte Carlo method based on particle filtering known as\nMIF for Likelihood Maximization by Iterated Filtering")
PSPO_names <- c("parallel simultaneous perturbation \noptimisation (PSPO)",
"parallel simultaneous perturbation optimization ")
# Recode the Other algorithm names with standardized name
clean_data_V7 <- clean_data_V6 |>
mutate(Other_Name.of.calibration.algorithm_V2= ifelse(Other_Name.of.calibration.algorithm %in% ABC_SMC_names, "Approximate Bayesian Computation Sequential Monte Carlo (ABC-SMC)",
ifelse(Other_Name.of.calibration.algorithm %in% HME_names, "History matching with emulation",
ifelse(Other_Name.of.calibration.algorithm %in% IMIS_names, "Incremental Mixture Importance Sampling (IMIS)",
ifelse(Other_Name.of.calibration.algorithm %in% MCF_names, "Monte-Carlo filtering",
ifelse(Other_Name.of.calibration.algorithm %in% SIR_names, "Sampling importance resampling (SIR)",
ifelse(Other_Name.of.calibration.algorithm %in% SMC_PF_names, "Sequential Monte Carlo (SMC)",
ifelse(Other_Name.of.calibration.algorithm %in% BM_names, "Bayesian melding",
ifelse(Other_Name.of.calibration.algorithm %in% NM_names, "Nelder-Mead algorithm",
ifelse(Other_Name.of.calibration.algorithm %in% PSPO_names, "Parallel Simultaneous perturbation Optimisation (PSPO)",
ifelse(Other_Name.of.calibration.algorithm == "Latin hypercube sampling", "Latin Hypercube Sampling",
ifelse(Other_Name.of.calibration.algorithm == " Levemberg–Marquard optimization algorithm ", "Levenberg-Marquardt optimization algorithm",
ifelse(Other_Name.of.calibration.algorithm == "A deviance-based loss was calculated using the following formula:\n\t ", "Deviance-based loss", ifelse(Other_Name.of.calibration.algorithm == "Multiobjective genetic algorithm", "Genetic algorithm", ifelse(Other_Name.of.calibration.algorithm == "Diffusion approximation, minimum constrast estimation", "Minimum contrast estimation", ifelse(Other_Name.of.calibration.algorithm == "Diffusion approximation, minimum constrast estimation", "Minimum contrast estimation", ifelse(Other_Name.of.calibration.algorithm == "adaptive population Monte Carlo Approximate Bayesian Computation\nalgorithm (APMC-ABC)", "Adaptive population Monte Carlo Approximate Bayesian Computation (APMC-ABC)", Other_Name.of.calibration.algorithm)))))))))))))))))|>
rename("Other_Name.of.calibration.algorithm_old"="Other_Name.of.calibration.algorithm",
"Other_Name.of.calibration.algorithm"="Other_Name.of.calibration.algorithm_V2")|>
select(-Other_Name.of.calibration.algorithm_old)
# Move algorithms from "Other" to "Name calibration algorithm"
## Upload data for coding the "AIMS" column
setwd("~/GitHub/Calibration-Review/0.Raw Data")
Aim_Alg_name <- read.xlsx("Aims_calibration_algorithm.xlsx", sheetName = "Sheet1")
## Move names
clean_data_V8 <- clean_data_V7 |>
mutate(Name.of.calibration.algorithm = ifelse(Other_Name.of.calibration.algorithm %in% Aim_Alg_name$Name.of.calibration.algorithm, Other_Name.of.calibration.algorithm, Name.of.calibration.algorithm),
Other_Name.of.calibration.algorithm=ifelse(Other_Name.of.calibration.algorithm %in% Aim_Alg_name$Name.of.calibration.algorithm, NA, Other_Name.of.calibration.algorithm))
# Add Aim columns
clean_data_V9 <- left_join(clean_data_V8, Aim_Alg_name) |>
mutate(Aim.of.calibration.procedure = ifelse(Name.of.calibration.algorithm == "Not reported", "Not reported ", Aim.of.calibration.procedure))
# Further Recode "Other Name calibration algorithm" manually.
setwd("~/GitHub/Calibration-Review/0.Raw Data")
Other_Name.of.calibration.algorithm_df <- read.xlsx("Other_Name.of.calibration.algorithm.xlsx", sheetName = "Sheet1") |>
mutate(Covidence.ID= as.character(Covidence.ID))
Recode <- clean_data_V9 |>
filter(Covidence.ID %in% Other_Name.of.calibration.algorithm_df$Covidence.ID)|>
select(-Name.of.calibration.algorithm, -Other_Name.of.calibration.algorithm, -Aim.of.calibration.procedure)
Recoded <-left_join(Recode, Other_Name.of.calibration.algorithm_df)|>
mutate(Name.of.calibration.algorithm= ifelse(Name.of.calibration.algorithm=="Other", "Other ", Name.of.calibration.algorithm))
clean_data_V10 <- rbind(clean_data_V9 |> filter(! Covidence.ID %in% Other_Name.of.calibration.algorithm_df$Covidence.ID) ,
Recoded)
setwd("~/GitHub/Calibration-Review/1.Data Cleaning")
write.csv(clean_data_V10, "Clean_data.csv", row.names = F)
# Clean environment
rm( list = ls() )
# load necessary libraries
library(tidyverse)
library(circlize)
library(cartography)
# Load data
setwd("~/GitHub/Calibration-Review/1.Data Cleaning")
clean_data <- read.csv("Clean_data.csv")
# chordDiagram
# install.packages("circlize")
clean_data |>
select(Aim.of.calibration.procedure, Model.type) |>
chordDiagram(grid.col = carto.pal(pal1 = "pastel.pal" ,n1 = 15)[c(9:16)])
# Barplot - Counts
clean_data |>
mutate(Model.type = factor(Model.type, levels= rev(c("Compartmental", "Individual-based", "Hawkes Process", "Other", "Not reported"))))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Model.type))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Model type") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15)[c(10:14)])
# Barplot - Proportions
clean_data |>
mutate(Model.type = factor(Model.type, levels= rev(c("Compartmental", "Individual-based", "Hawkes Process", "Other", "Not reported"))))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Model.type))+
geom_bar(position = "fill") +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Proportion") +
labs(fill = "Model type") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15)[c(10:14)])
clean_data |>
select(Aim.of.calibration.procedure, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
separate_rows(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., sep = "; ")|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Type of data used to define calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15)[c(10:14)])
clean_data |>
select(Aim.of.calibration.procedure, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
separate_rows(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., sep = "; ")|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Type of data used to define calibration targets")
clean_data |>
select(Aim.of.calibration.procedure, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
separate_rows(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., sep = "; ")|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Type of data used to define calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15))
# Barplot - Proportions
clean_data |>
select(Aim.of.calibration.procedure, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
separate_rows(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., sep = "; ")|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))+
geom_bar(position = "fill") +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Type of data used to define calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15))
clean_data |>
select(Aim.of.calibration.procedure, Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.)|>
separate_rows(Type.of.data.used.for.defining.calibration.targets..select.all.that.apply., sep = "; ")|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Type.of.data.used.for.defining.calibration.targets..select.all.that.apply.))+
geom_bar(position = "fill") +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Type of data used to define calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 15))
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
ggplot(aes(x=calibration_algorithm_aim, fill = Resolution_of_data))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 20)[c(16:20)])
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
ggplot(aes(x=calibration_algorithm_aim, fill = Resolution_of_data))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets")
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Resolution_of_data))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 20)[c(16:20)])
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
mutate(Resolution_of_data= factor(Resolution_of_data, levels= c("Empirical data", "Modeled estimates", "Both empirical data and modeled estimates", "Not reported")))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Resolution_of_data))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 20)[c(16:20)])
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
mutate(Resolution_of_data= factor(Resolution_of_data, levels= rev(c("Empirical data", "Modeled estimates", "Both empirical data and modeled estimates", "Not reported"))))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Resolution_of_data))+
geom_bar() +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 20)[c(16:20)])
clean_data |>
mutate(Resolution_of_data= ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Empirical data or statistical summaries of empirical data (e.g., WHO case notification data) ", "Empirical data",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Modeled estimates  (e.g., WHO TB incidence estimates)", "Modeled estimates",
ifelse(Resolution.of.data..used.for.defining.calibration.targets=="Not reported ", "Not reported", "Both empirical data and modeled estimates"))))|>
mutate(Resolution_of_data= factor(Resolution_of_data, levels= rev(c("Empirical data", "Modeled estimates", "Both empirical data and modeled estimates", "Not reported"))))|>
ggplot(aes(x=Aim.of.calibration.procedure, fill = Resolution_of_data))+
geom_bar(position = "fill") +
theme_classic() +
xlab("Aim of calibration algorithm") +
ylab("Count") +
labs(fill = "Resolution of the data used\nfor defining calibration targets") +
scale_fill_manual(values = carto.pal(pal1 = "pastel.pal" ,n1 = 20)[c(16:20)])
